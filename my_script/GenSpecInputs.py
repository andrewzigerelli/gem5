#!/usr/bin/python3
import os
import sys
import subprocess
import re
import pickle
from itertools import combinations

# run directions
#       python GenSpecInputs.py SPEC_PATH SPEC_DIR_NUM MODE COMBO_NUM"
# e.g.
#       python GenSpecInputs.py /opt/spec2017 0001 3
# will generate readfiles, with combinations of 3 benchmarks, from 0001 dir
# SPEC_DIR_NUM is from compiling spec, see spec readme

# readfile for FS mode is straightforward: just command to be run in gem5 as
#   input script
#   NOTE: fs cmd generated byt SPEC is stupid: it does cd DIR; ../DIR/cmd
#         instead of ./cmd

# for SE mode, it's 5 lines
#  0:  cmd
#  1:  options
#  2:  input
#  3:  output file name
#  4:  stderr file name

SPEC2017 = []  # global array of benchmarks


def main():
    # get spec2017 path
    try:
        specPath = sys.argv[1]
    except:
        errMsg = "Need to give Spec2017 path as argument! "
        errMsg += "e.g. \n python GenSpecInputs.py /opt/spec2017 0001 3"
        raise ValueError(errMsg)

    try:
        runSuffix = sys.argv[2]
    except:
        errMsg = "Need to give run dir numbers as argument. "
        errMsg += "e.g. \n python GenSpecInputs.py /opt/spec2017 0001 3"
        raise ValueError(errMsg)

    try:
        num_combo = sys.argv[3]
        num_combo = int(num_combo.rstrip())
    except:
        errMsg = "Need to give num_combo arg as an int"
        errMsg += "e.g. \n python GenSpecInputs.py /opt/spec2017 0001 3"
        raise ValueError(errMsg)

    # add benchspec/CPU
    # call join twice to be OS agnostic
    benchesPath = os.path.join(specPath, "benchspec")
    benchesPath = os.path.join(benchesPath, "CPU")

    if os.path.isdir(benchesPath):
        # we can set specinvoke path
        specinvokePath = os.path.join(specPath, "bin")
        specinvokeBin = os.path.join(specinvokePath, "specinvoke")
    else:
        raise ValueError("Spec2017 benchmark path not found")

    # get benchmarks
    benches = {}
    dirs = [
        d for d in os.listdir(benchesPath)
        if os.path.isdir(os.path.join(benchesPath, d))
    ]
    benches = {d: os.path.join(benchesPath, d) for d in dirs}

    # open command file
    specFile = open("spec_cmds.txt", "w")
    try:
        os.mkdir("readfiles")
    except FileExistsError:
        pass

    # get and write commandline
    for bench, benchdir in benches.items():
        # check if there are runfolders
        runFolder = os.path.join(benchdir, "run")
        if not os.path.isdir(runFolder):
            print("Warning: %s doesn't exist" % runFolder)
            continue
        folders = [
            os.path.join(runFolder, f) for f in os.listdir(runFolder)
            if os.path.isdir(os.path.join(runFolder, f))
        ]
        # run folders end in name.xxxx, where xxxx is number
        regex = "." + runSuffix + "$"
        regex = re.compile(regex)
        folder = ''.join(filter(regex.search, folders))
        speccmds = os.path.join(folder, 'speccmds.cmd')
        if not os.path.exists(speccmds):
            print("Warning: %s doesn't exist" % speccmds)
            print("skipping %s" % bench)
            continue

        # call specinvoke
        speccmd = [specinvokeBin, "-nn", speccmds]
        speccmd = subprocess.Popen(speccmd, stdout=subprocess.PIPE)
        spec_out = speccmd.communicate()[0]
        spec_out = spec_out.decode(sys.stdin.encoding)
        start = spec_out.find("# Starting run for copy")
        last = spec_out.find("specinvoke exit")
        substring = spec_out[start:last]
        parseCmd(substring, bench)
        specFile.write(substring+"\n")

    # write to
    specFile.close()

    # make combinations and write to readfile
    combos = combinations(SPEC2017, num_combo)
    cwd = os.getcwd()
    fsReadfileDir = os.path.join(cwd, "readfiles")
    seReadfileDir = os.path.join(cwd, "se_readfiles")
    for combo in combos:
        combo_name = ""
        fs_cmds = ""
        se_cmds = ""
        options = ""
        inputs = ""
        outputs = ""
        stderrs = ""

        for bench in combo:
            # readfiles
            combo_name = combo_name + bench.name + "_" + str(bench.num) + "_"
            fs_cmds = fs_cmds + bench.fs_cmd + " & "
            se_cmds = se_cmds + bench.se_cmd + ";"
            options = options + bench.options + ";"
            inputs = inputs + bench.input + ";"
            outputs = outputs + bench.output + ";"
            stderrs = stderrs + bench.stderr + ";"

        # fix up strings
        readfile_name = combo_name + "readfile"
        # remove last & and add exit command
        fs_cmds = fs_cmds.strip(' &')
        fs_cmds = fs_cmds + ";m5 exit;"
        # remove last ;
        se_cmds = se_cmds[:-1]
        options = options[:-1]
        inputs = inputs[:-1]
        outputs = outputs[:-1]
        stderrs = stderrs[:-1]

        # write fs readfile
        fsReadfile = os.path.join(fsReadfileDir, readfile_name)
        with open(fsReadfile, "w") as f:
            f.write(fs_cmds)

        # write se readfile
        seReadfile = os.path.join(seReadfileDir, readfile_name)
        with open(seReadfile, "w") as f:
            f.write(se_cmds + "\n")
            f.write(options + "\n")
            f.write(inputs + "\n")
            f.write(outputs + "\n")
            f.write(stderrs)


class benchmark:
    def __init__(self, name, num):
        self.name = name
        self.num = num
        self.fs_cmd = None
        self.se_cmd = None
        self.options = None
        self.input = None
        self.output = None
        self.stderr = None


def parseCmd(cmd, bench):
    # start to parse cmd
    lines = cmd.splitlines()

    # regex for parsing se mode
    cmdRegex = "^([^><]+?)?(< .+?)?(> .+?)?(2>> .+)$"
    cmdRegex = re.compile(cmdRegex)

    textRegex = "\s+.*"
    textRegex = re.compile(textRegex)

    i = 0
    while len(lines) != 0:
        # create benchmark object
        thisBench = benchmark(bench, i)
        del lines[0]

        # fs mode
        command = lines[0] + ";" + lines[1]  # + ";m5 exit;"
        thisBench.fs_cmd = command

        # se mode
        runFolder = lines[0][3:]
        # thisBench.dir = runFolder
        binaryNamePosEnd = lines[1].find(' ')
        binary = lines[1][:binaryNamePosEnd]
        cmd = os.path.basename(os.path.normpath(binary))
        cmd = os.path.join(runFolder, cmd)
        rest = lines[1][binaryNamePosEnd + 1:]

        thisBench.se_cmd = cmd

        # parse input options
        result = cmdRegex.search(rest)
        result = result.groups()

        options = result[0]
        if options:
            options = options.rstrip()
            options = fixOptions(options, runFolder)
            thisBench.options = options
        else:
            thisBench.options = ""

        stdin = result[1]
        if stdin:
            stdin = stdin.rstrip()
            text = textRegex.search(stdin)
            text = text.group(0).lstrip()
            # append runFolder
            input_ = os.path.join(runFolder, text)
            thisBench.input = input_
        else:
            thisBench.input = ""

        stdout = result[2]
        if stdout:
            stdout = stdout.rstrip()
            text = textRegex.search(stdout)
            text = text.group(0).lstrip()
            thisBench.output = text
        else:
            thisBench.output = ""

        stderr = result[3]
        if stderr:
            stderr = stderr.rstrip()
            text = textRegex.search(stderr)
            text = text.group(0).lstrip()
            thisBench.stderr = text
        else:
            thisBench.stderr = ""

        SPEC2017.append(thisBench)
        del lines[0:2]
        i += 1


def fixOptions(options, runFolder):
    # some benchmarks may read from a file and specify this file as an arg,
    # not in stdin, so we must determine if the option needs the full path
    # appended

    new_options = []
    options = options.split()
    for option in options:
        test_option = os.path.join(runFolder, option)
        # test if it exists
        if os.path.exists(test_option):
            # option is a file, use the appended path
            option = test_option
        new_options.append(option)

    # make quote string
    new_options = '"' + ' '.join(new_options) + '"'
    return new_options


def save_obj(obj, name):
    with open(name + '.pkl', 'wb') as f:
        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)


def load_obj(name):
    with open(name + '.pkl', 'rb') as f:
        return pickle.load(f)


if __name__ == "__main__":
    main()
